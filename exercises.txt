1. semaphore solution avoids starvation by checking if there are any mice waiting as soon as 2 cats have gone and if so then allows the mice to go into the kitchen before any more cats are allowed to. if no mice are waiting then two more cats are allowed to go in. This gives mice priority and keeps them from starving. after two mice eat in the kitchen then two cats are allowed into the kitchen allowing cats and mice to take turns and therefore avoids starvation for both cats and mice. The lock solution avoids starvation in a similar way. If there are any mice waiting to enter the kitchen, and two cats have already gone in this turn for cats, then they are allowed into the kitchen if there are currently no cats in the kitchen giving them priority over the cats. if 2 mice have gone this turn then the cats are allowed back into the kitchen again, and as long as there are no mice waiting they continue to be allowed into the kitchen. to eat, but when mice begin to wait again, then they are given priority and all cats must wait until the mice have gone before being allowed back into the kitchen
2. After completing this problem with both design principles, we can see that they could both be used in many ways to solve many type of synchronization problems. We discovered the advantages and disadvantages of both cvâ€™s and lock and a semaphore implementation. For example, whenever you want to signal more than one resources is available for a semaphore implementation, you must signal two different times instead of simply setting the lock count to the desired number as you can with locks and conditional variables. We used this to control the number of mice or cats allowed to eat in their turn. The conditional variable implementation is better for waiting on certain conditions instead of just waiting to acquire the lock where as in a semaphore implementation, it is best used in a scenario where you are simply waiting on a resource, where as conditional variables seem better for allowing for conditions to be met while you are waiting, since you can constantly call cv_wait() where you can only call wait(() for a semaphore once at a time because otherwise you would continually decrement your semaphore counter and no one would ever be able to go. Both of these synchronization philosophies can be used to solve the same problem, but both have their own individual advantages that make them useful in comparative ways. 
